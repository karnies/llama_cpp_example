#include "llama.h"
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <iostream>

int main() {
    // 모델 경로
    // const char* model_path = "./models/EXAONE-4.0-1.2B-BF16.gguf";
    const char* model_path = "./models/EXAONE-4.0-1.2B-Q4_K_M.gguf";
    int n_predict = 512;

    // 프롬프트를 코드에 하드코딩
    std::string prompt = R"PROMPT(<thought>
다음은 OCR로 인식된 박스 텍스트 목록입니다. 아래 규칙에 따라 사건번호, 채무자 이름, 판사 이름, 문서 작성일자, 법원 이름, 신청대리인 법무사 이름을 하나씩 정확히 추출하세요.

---

### [추출 규칙]
1. **사건번호**
   - "2024개회123456"과 같은 형식 ("yyyy개회nnnnnn")
   - "개인회생", "사건에 관하여" 등의 텍스트 근처에서 추출

2. **채무자 이름**
   - "채무자" 또는 "재무자"가 들어 있는 박스 다음 박스
   - 한글 2~4자로 된 이름

3. **판사 이름**
   - 문서의 마지막 부분에 위치
   - "판사"라는 단어가 있는 박스의 다음 박스에서 한글 이름 추출
   - "정본입니다", "문현정" 등은 제외
   - 가장 마지막에 등장하는 "판사" 박스를 기준으로 추출

4. **문서 작성일자**
   - "2023", "9", "13"처럼 **yyyy. mm. dd.** 형식으로 등장하는 숫자 3개 조합
   - 보통 문서 중간이나 하단에 위치
   - 연속된 박스 3개에서 각각 연도, 월, 일을 나타냄
   - 예: 2023년 9월 13일 → Box A: 2023, Box B: 9, Box C: 13

5. **법원 이름**
   - 보통 문서 상단에 위치
   - "수원회생법원", "서울중앙지방법원"과 같은 형식
   - "법원"이라는 단어가 포함되어 있으며, 괄호나 숫자가 없어야 함

6. **신청대리인 법무사 이름**
   - 보통 채무자 주소 아래에 위치
   - "신청대리인" 또는 "법무사"라는 단어가 들어 있는 박스 다음 박스

---
- OCR 결과는 다음과 같은 순서로 나온다
  - 박스 좌표 (4점), recognized letters (string), score(float)

---

### OCR 결과
(886,501) (1578,497) (1578,577) (886,581) 수원회생법원 0.862833
(1725,559) (2056,563) (2055,647) (1725,643) 정본입니다 0.999924
(1792,669) (1919,669) (1919,731) (1792,731) 2024 0.999974
(1924,672) (1991,672) (1991,727) (1924,727) 9 0.955336
(1973,672) (2056,672) (2056,727) (1973,727) 13 0.998743
(1676,731) (1908,731) (1908,793) (1676,793) 법원주사보 0.992508
(1916,731) (2058,731) (2058,793) (1916,793) 문현정 0.890698
(1128,811) (1345,811) (1345,884) (1128,884) 개인회생 0.974085
(707,822) (1084,815) (1085,877) (708,885) 2024개회234353 0.983008
(710,935) (868,939) (867,1009) (709,1005) 최용접 0.847115
(240,950) (292,950) (292,1001) (240,1001) 그 0.0981571
(878,946) (935,946) (935,1001) (878,1001) 6 0.348699
(1131,946) (1183,946) (1183,990) (1131,990) - 0.927887
(1454,1009) (1539,1009) (1539,1074) (1454,1074) 19 0.745216
(1722,1009) (1833,1009) (1833,1071) (1722,1071) 호관 0.789143
(2097,1005) (2192,1005) (2192,1071) (2097,1071) 라 0.208606
(715,1016) (870,1016) (870,1078) (715,1078) 안양시 0.835643
(875,1016) (1043,1016) (1043,1078) (875,1078) 동안구 0.927434
(901,1085) (1123,1085) (1123,1158) (901,1158) [안산시 0.736381
(1531,1085) (1619,1085) (1619,1151) (1531,1151) 82 0.919579
(1808,1082) (1981,1082) (1981,1155) (1808,1155) 고잔동 0.81104
(718,1093) (924,1093) (924,1155) (718,1155) 송달장소 0.986089
(1490,1096) (1521,1096) (1521,1129) (1490,1129)  0.0
(1635,1093) (1691,1093) (1691,1147) (1635,1147) 4% 0.678529
(715,1166) (968,1166) (968,1228) (715,1228) 신청대리인 0.953142
(986,1158) (1157,1158) (1157,1231) (986,1231) 법무사 0.976958
(1165,1158) (1325,1158) (1325,1231) (1165,1231) 은경수 0.763645
(1082,1359) (1134,1359) (1134,1418) (1082,1418) 주 0.998578
(1348,1356) (1405,1356) (1405,1418) (1348,1418) 문 0.999285
(454,1473) (568,1473) (568,1538) (454,1538) 대한 0.999924
(648,1473) (764,1473) (764,1538) (648,1538) 법원 0.944536
(788,1473) (1172,1473) (1172,1535) (788,1535) 22024개회234353 0.958751
(1175,1465) (1363,1465) (1363,1538) (1175,1538) 사건에 0.998093
(1335,1465) (1526,1465) (1526,1538) (1335,1538) 관하여 0.995764
(1539,1469) (1890,1469) (1890,1531) (1539,1531) 개인회생생절차의 0.888129
(1916,1466) (2177,1461) (2177,1531) (1916,1535) 개시신정에 0.921364
(235,1476) (434,1476) (434,1538) (235,1538) 재무가에 0.700435
(581,1476) (640,1476) (640,1535) (581,1535) 이 0.2588
(2198,1469) (2249,1469) (2249,1527) (2198,1527) 대 0.987845
(235,1549) (289,1549) (289,1611) (235,1611) 한 0.992354
(307,1546) (462,1546) (462,1619) (307,1619) 결정이 0.990679
(478,1546) (591,1546) (591,1622) (478,1622) 있을 0.99906
(607,1549) (762,1549) (762,1611) (607,1611) 때가지 0.936007
(780,1542) (937,1542) (937,1615) (780,1615) 다음의 0.965879
(958,1549) (1015,1549) (1015,1608) (958,1608) 각 0.663861
(1030,1546) (1147,1546) (1147,1611) (1030,1611) 철자 0.647896
(1160,1541) (1279,1546) (1278,1616) (1158,1611) 또는 0.999923
(1291,1546) (1449,1546) (1449,1608) (1291,1608) 행위를 0.999823
(1456,1542) (1681,1538) (1682,1604) (1457,1608) 금기한다 0.868301
(847,1692) (1010,1692) (1010,1765) (847,1765) 재무자 0.960994
(1601,1692) (2068,1692) (2068,1754) (1601,1754) 임차보증금반환채권 0.945261
(2076,1685) (2241,1685) (2241,1758) (2076,1758) 영업을 0.965094
(302,1696) (658,1696) (658,1769) (302,1769) 개인회생재권에 0.996316
(669,1696) (831,1696) (831,1769) (669,1769) 기하여 0.947413
(1025,1699) (1185,1699) (1185,1761) (1025,1761) 소유의 0.983785
(1195,1696) (1585,1692) (1586,1761) (1196,1765) 유체동산영업장 0.956818
(235,1710) (274,1710) (274,1758) (235,1758) 1 0.835281
(1245,1765) (1405,1765) (1405,1838) (1245,1838) 대하여 0.999743
(1420,1769) (1529,1769) (1529,1831) (1420,1831) 하는 0.999191
(1547,1769) (1921,1769) (1921,1831) (1547,1831) 강제집행기압류 0.865219
(2056,1761) (2231,1761) (2231,1834) (2056,1834) 가저분 0.789594
(312,1772) (467,1772) (467,1845) (312,1845) 통하여 0.99869
(478,1776) (591,1776) (591,1838) (478,1838) 언는 0.987491
(612,1772) (728,1772) (728,1838) (612,1838) 재권 0.966501
(749,1772) (950,1772) (950,1834) (749,1834) 예금재권 0.933268
(974,1772) (1030,1772) (1030,1834) (974,1834) 등 0.997456
(1046,1772) (1229,1772) (1229,1834) (1046,1834) 포함에 0.999582
(1932,1772) (2043,1772) (2043,1823) (1932,1823) 또는 0.999492
(300,1845) (661,1845) (661,1918) (300,1918) 개인회생재권을 0.993611
(671,1838) (937,1838) (937,1922) (671,1922) 변제받거나 0.989909
(230,1849) (281,1849) (281,1911) (230,1911) 2 0.995967
(950,1842) (1108,1842) (1108,1918) (950,1918) 변제를 0.99232
(1128,1849) (1340,1849) (1340,1911) (1128,1911) 요구하는 0.998553
(1358,1842) (1516,1842) (1516,1915) (1358,1915) 일체의 0.999635
(1534,1842) (1653,1842) (1653,1907) (1534,1907) 행위 0.854132
(1666,1842) (1792,1842) (1792,1907) (1666,1907) 다만 0.725297
(1800,1842) (2068,1834) (2069,1903) (1801,1912) 소송행위를 0.967304
(2076,1842) (2190,1842) (2190,1907) (2076,1907) 제와 0.928349
(318,1926) (431,1926) (431,1992) (318,1992) 한다 0.998345
(1087,2072) (1144,2072) (1144,2134) (1087,2134) 이 0.998238
(1353,2068) (1413,2068) (1413,2141) (1353,2141) 유 0.997847
(1454,2207) (1660,2207) (1660,2280) (1454,2280) 적용하여 0.998101
(1673,2207) (1836,2207) (1836,2280) (1673,2280) 주문과 0.999481
(1846,2203) (1960,2203) (1960,2280) (1846,2280) 같이 0.991828
(1968,2200) (2195,2200) (2195,2284) (1968,2284) 결정한다 0.999934
(238,2214) (404,2218) (403,2292) (237,2287) 개무자 0.836837
(449,2218) (522,2218) (522,2288) (449,2288) 생 0.973765
(612,2218) (770,2218) (770,2280) (612,2280) 파산에 0.77309
(788,2214) (899,2214) (899,2280) (788,2280) 관한 0.998238
(909,2211) (1025,2211) (1025,2288) (909,2288) 법률 0.96476
(1041,2218) (1229,2218) (1229,2280) (1041,2280) 제5조 0.969236
(1247,2211) (1438,2211) (1438,2284) (1247,2284) 제1항을 0.984728
(416,2222) (470,2222) (470,2284) (416,2284) 회 0.74428
(540,2222) (594,2222) (594,2284) (540,2284) 및 0.998466
(1108,2657) (1240,2657) (1240,2719) (1108,2719) 2024 0.99966
(1252,2657) (1309,2657) (1309,2719) (1252,2719) 0 0.521057
(1322,2653) (1400,2653) (1400,2719) (1322,2719) 10 0.888654
(1005,2887) (1113,2887) (1113,2953) (1005,2953) 판사 0.738877
(1260,2887) (1410,2887) (1410,2949) (1260,2949) 정수미 0.959155
(560,3154) (733,3150) (734,3212) (560,3216) 바코드로 0.91251
(739,3154) (997,3154) (997,3216) (739,3216) 대한민국법원 0.991033
(1002,3154) (1141,3154) (1141,3216) (1002,3216) 앤에서 0.810819
(1143,3150) (1366,3146) (1366,3215) (1144,3220) 진위확인을 0.865065
(224,3161) (560,3153) (561,3219) (225,3227) 문서좌측상단의 0.785168
(1371,3154) (1459,3154) (1459,3208) (1371,3208) 하실 0.911084
(1474,3161) (1513,3161) (1513,3208) (1474,3208) 수 0.962583
(1526,3154) (1707,3154) (1707,3205) (1526,3205) 있습니다 0.981021
(1712,3154) (1810,3154) (1810,3205) (1712,3205) 또한 0.986414
(1813,3154) (2167,3154) (2167,3205) (1813,3205) 전자소송음페지 0.692419
(186,3172) (232,3172) (232,3208) (186,3208) _ 0.479253
(1134,3201) (1283,3201) (1283,3263) (1134,3263) 조조회 0.681129
(1289,3201) (1467,3201) (1467,3263) (1289,3263) 메뉴에서 0.976682
(1474,3201) (1565,3201) (1565,3256) (1474,3256) 문서 0.961306
(1573,3201) (1663,3201) (1663,3256) (1573,3256) 좌족 0.796181
(1662,3198) (1797,3193) (1798,3255) (1663,3260) 하단의 0.979984
(1802,3201) (2017,3201) (2017,3252) (1802,3252) 발급번호를 0.88999
(2200,3194) (2309,3194) (2309,3256) (2200,3256) 위번 0.718024
(189,3212) (212,3212) (212,3249) (189,3249)  0.0
(547,3213) (724,3200) (726,3259) (549,3271) 사건검색 0.879647
(723,3205) (901,3205) (901,3267) (723,3267) 컴퓨터의 0.999134
(232,3256) (553,3256) (553,3307) (232,3307) 부를확인하실 0.828349
(537,3263) (597,3263) (597,3303) (537,3303) _ 0.614578
(602,3256) (782,3256) (782,3307) (602,3307) 있습니다 0.997803
(2017,3358) (2378,3354) (2379,3406) (2017,3409)  0.0
</thought>)PROMPT";

    // llama.cpp 백엔드 초기화
    llama_backend_init();

    // 모델 파라미터 및 모델 로드
    llama_model_params model_params = llama_model_default_params();
    llama_model* model = llama_model_load_from_file(model_path, model_params);
    if (!model) {
        std::cerr << "모델 로드 실패: " << model_path << std::endl;
        return 1;
    }
    const llama_vocab* vocab = llama_model_get_vocab(model);

    // 프롬프트 토크나이즈
    int n_prompt = -llama_tokenize(vocab, prompt.c_str(), prompt.size(), NULL, 0, true, true);
    std::vector<llama_token> prompt_tokens(n_prompt);
    if (llama_tokenize(vocab, prompt.c_str(), prompt.size(), prompt_tokens.data(), prompt_tokens.size(), true, true) < 0) {
        std::cerr << "프롬프트 토크나이즈 실패" << std::endl;
        llama_model_free(model);
        return 1;
    }
    std::cout << "프롬프트 토큰 수(n_prompt): " << n_prompt << std::endl;

    // BF16 모델이면 context window와 batch를 2048로 제한
    llama_context_params ctx_params = llama_context_default_params();
    std::string model_path_str(model_path);
    if (model_path_str.find("BF16") != std::string::npos || model_path_str.find("F16") != std::string::npos) {
        ctx_params.n_ctx = 2048;
        ctx_params.n_batch = n_prompt;
        std::cout << "BF16/F16 모델: context window는 2048, batch는 프롬프트 토큰 수(" << n_prompt << ")로 설정합니다." << std::endl;
        if (n_prompt > 512) {
            std::cout << "경고: 프롬프트 토큰 수가 512를 초과하므로 메모리 부족이 발생할 수 있습니다." << std::endl;
        }
    } else {
        ctx_params.n_ctx = n_prompt + n_predict - 1;
        ctx_params.n_batch = n_prompt;
    }
    ctx_params.no_perf = false;
    llama_context* ctx = llama_init_from_model(model, ctx_params);
    if (!ctx) {
        std::cerr << "컨텍스트 생성 실패" << std::endl;
        llama_model_free(model);
        return 1;
    }

    // 샘플러 초기화 (greedy)
    auto sparams = llama_sampler_chain_default_params();
    sparams.no_perf = false;
    llama_sampler* smpl = llama_sampler_chain_init(sparams);
    llama_sampler_chain_add(smpl, llama_sampler_init_top_p(0.95f, 1));
    llama_sampler_chain_add(smpl, llama_sampler_init_temp(0.6f));
    llama_sampler_chain_add(smpl, llama_sampler_init_greedy());

    // 프롬프트 출력
    for (auto id : prompt_tokens) {
        char buf[128];
        int n = llama_token_to_piece(vocab, id, buf, sizeof(buf), 0, true);
        if (n < 0) {
            std::cerr << "토큰→문자열 변환 실패" << std::endl;
            llama_sampler_free(smpl);
            llama_free(ctx);
            llama_model_free(model);
            return 1;
        }
        std::string s(buf, n);
        std::cout << s;
    }
    std::cout << std::flush;

    // 배치 준비 및 프롬프트 디코딩 (n_batch 단위로 분할)
    int n_consumed = 0;
    while (n_consumed < n_prompt) {
        int n_to_process = std::min<int>(ctx_params.n_batch, n_prompt - n_consumed);
        llama_batch batch = llama_batch_get_one(prompt_tokens.data() + n_consumed, n_to_process);
        if (llama_decode(ctx, batch)) {
            std::cerr << "llama_decode 실패" << std::endl;
            llama_sampler_free(smpl);
            llama_free(ctx);
            llama_model_free(model);
            llama_backend_free();
            return 1;
        }
        n_consumed += n_to_process;
    }

    // 생성 루프
    const llama_token eos_token = llama_vocab_eos(vocab);
    llama_token new_token_id;
    int n_pos = n_prompt;
    for (; n_pos < n_prompt + n_predict;) {
        new_token_id = llama_sampler_sample(smpl, ctx, -1);
        if (new_token_id == eos_token) {
            break;
        }
        char buf[128];
        int n = llama_token_to_piece(vocab, new_token_id, buf, sizeof(buf), 0, true);
        if (n < 0) {
            std::cerr << "토큰→문자열 변환 실패" << std::endl;
            break;
        }
        std::string s(buf, n);
        std::cout << s << std::flush;
        llama_batch batch = llama_batch_get_one(&new_token_id, 1);
        if (llama_decode(ctx, batch)) {
            std::cerr << "llama_decode 실패" << std::endl;
            break;
        }
        n_pos += 1;
    }
    std::cout << std::endl;

    // 자원 해제
    llama_sampler_free(smpl);
    llama_free(ctx);
    llama_model_free(model);
    llama_backend_free();
    return 0;
} 